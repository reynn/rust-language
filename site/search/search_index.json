{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rust Resources Motivations Stumbles with Go Stumbles with Python How Rust may help solve these problems Stumbles we are likely to have with Rust Learning materials Sub Pages Basic project structure Reference Material Testing Code documentation Doc Links Doc Examples Some Useful Cargo plugins Crates (Libraries) Motivations Stumbles with Go Projects: support-clerk, mi6 lack of pre-defined project structures it was difficult to find one that lasted and made sense to everyone on the team. #1 also lead to difficulty in code management and maintenance go mod while initially a big win for the community finally having a general package management tool has not gone as well as hoped and the syntax becomes difficult due to custom DSL used instead of common Lack of some typical data structures in addition to lack of generics lead to lots of boilerplate that was being solved in ways that are not best practice. At least one library we were using has been broken randomly by the author changing the name. Go build is a very simple build tool so it only builds a single binary at a time. This leads to additional software to manage builds like Mage to effectively handle building for Serverless applications. Stumbles with Python Projects: herald, several other bot trials Deploy/Build methods Code being in production Lack of strict typing lead to many failures only discovered in production How Rust may help solve these problems cargo is the only package management tool and is heavily influenced by the community. It uses TOML which is a common data structure used in many cloud native software tools. cargo is the tool that can do basically everything, it is the software install tool like pip using cargo install exa for instance. It also handles testing, doc building, project initialization and much more as well as having plugin crates to extend functionality further. cargo and rust having a set structure also allows cargo to manage multiple binary builds on it's own by passing a --bins this will simplify the build process for us significantly. Stumbles we are likely to have with Rust Rust has a newer type of memory management called a Ownership . The concept seems easy at first but it is a hurdle that could take a few weeks for everyone to fully understand. The up side to this however is it allows compile time checks of memory management so that null pointers are rare occurrences in production. Learning materials Good places to get started learning Rust from the basics of installation to async programming and procedural macros. [ Official Book Online ] [ Official Book Kindle/Paperback ] [ Cargo Book ] [ Build a CLI app ] Sub Pages [ Cargo ] [ Crates ] [ Language Features ] [ Patterns ] Basic project structure Reference Material These links will be more focused on places to quickly look up info including compiler errors and CLI commands. [ Rust By Example ] [ Compiler Error Index ] Testing Rust gives a few ways to do testing including typical unit and integration testing as well as a great doc testing feature. [ Rust By Example - Testing ] Code documentation Rust provides a full markdown engine for code documentation using a /// block. In you can document the crate and submodules with markdown using //! that summarizes usage of the crate or module. Doc Links [ Rust By Example - Documentation ] Doc Examples /// A human being is represented here pub struct Person { /// A person must have a name, no matter how much Juliet may hate it name: String, } impl Person { /// Returns a person with the name given them /// /// # Arguments /// /// * `name` - A string slice that holds the name of the person /// /// # Example /// /// ``` /// // You can have rust code between fences inside the comments /// // If you pass --test to Rustdoc, it will even test it for you! /// use doc::Person; /// let person = Person::new(\"name\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// Gives a friendly hello! /// /// Says \"Hello, [name]\" to the `Person` it is called on. pub fn hello(& self) { println!(\"Hello, {}!\", self.name); } } Some Useful Cargo plugins These add extra commands to cargo that make it even more useful! [ cargo-add ] - Add dependencies to your Cargo.toml without having to manually edit the file. console $ cargo install cargo-add --force Updating crates.io index Installing cargo-add v0.2.0 ... Finished release [optimized] target(s) in 14.65s Replacing /Users/reynn/.cargo/bin/cargo-add $ cargo add clap $ cargo add clap --version '~2.3' Crates (Libraries) See [] for a complete run down of crates.","title":"Rust Resources <!-- omit in toc -->"},{"location":"#rust-resources","text":"Motivations Stumbles with Go Stumbles with Python How Rust may help solve these problems Stumbles we are likely to have with Rust Learning materials Sub Pages Basic project structure Reference Material Testing Code documentation Doc Links Doc Examples Some Useful Cargo plugins Crates (Libraries)","title":"Rust Resources "},{"location":"#motivations","text":"","title":"Motivations"},{"location":"#stumbles-with-go","text":"Projects: support-clerk, mi6 lack of pre-defined project structures it was difficult to find one that lasted and made sense to everyone on the team. #1 also lead to difficulty in code management and maintenance go mod while initially a big win for the community finally having a general package management tool has not gone as well as hoped and the syntax becomes difficult due to custom DSL used instead of common Lack of some typical data structures in addition to lack of generics lead to lots of boilerplate that was being solved in ways that are not best practice. At least one library we were using has been broken randomly by the author changing the name. Go build is a very simple build tool so it only builds a single binary at a time. This leads to additional software to manage builds like Mage to effectively handle building for Serverless applications.","title":"Stumbles with Go"},{"location":"#stumbles-with-python","text":"Projects: herald, several other bot trials Deploy/Build methods Code being in production Lack of strict typing lead to many failures only discovered in production","title":"Stumbles with Python"},{"location":"#how-rust-may-help-solve-these-problems","text":"cargo is the only package management tool and is heavily influenced by the community. It uses TOML which is a common data structure used in many cloud native software tools. cargo is the tool that can do basically everything, it is the software install tool like pip using cargo install exa for instance. It also handles testing, doc building, project initialization and much more as well as having plugin crates to extend functionality further. cargo and rust having a set structure also allows cargo to manage multiple binary builds on it's own by passing a --bins this will simplify the build process for us significantly.","title":"How Rust may help solve these problems"},{"location":"#stumbles-we-are-likely-to-have-with-rust","text":"Rust has a newer type of memory management called a Ownership . The concept seems easy at first but it is a hurdle that could take a few weeks for everyone to fully understand. The up side to this however is it allows compile time checks of memory management so that null pointers are rare occurrences in production.","title":"Stumbles we are likely to have with Rust"},{"location":"#learning-materials","text":"Good places to get started learning Rust from the basics of installation to async programming and procedural macros. [ Official Book Online ] [ Official Book Kindle/Paperback ] [ Cargo Book ] [ Build a CLI app ]","title":"Learning materials"},{"location":"#sub-pages","text":"[ Cargo ] [ Crates ] [ Language Features ] [ Patterns ]","title":"Sub Pages"},{"location":"#basic-project-structure","text":"","title":"Basic project structure"},{"location":"#reference-material","text":"These links will be more focused on places to quickly look up info including compiler errors and CLI commands. [ Rust By Example ] [ Compiler Error Index ]","title":"Reference Material"},{"location":"#testing","text":"Rust gives a few ways to do testing including typical unit and integration testing as well as a great doc testing feature. [ Rust By Example - Testing ]","title":"Testing"},{"location":"#code-documentation","text":"Rust provides a full markdown engine for code documentation using a /// block. In you can document the crate and submodules with markdown using //! that summarizes usage of the crate or module.","title":"Code documentation"},{"location":"#doc-links","text":"[ Rust By Example - Documentation ]","title":"Doc Links"},{"location":"#doc-examples","text":"/// A human being is represented here pub struct Person { /// A person must have a name, no matter how much Juliet may hate it name: String, } impl Person { /// Returns a person with the name given them /// /// # Arguments /// /// * `name` - A string slice that holds the name of the person /// /// # Example /// /// ``` /// // You can have rust code between fences inside the comments /// // If you pass --test to Rustdoc, it will even test it for you! /// use doc::Person; /// let person = Person::new(\"name\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// Gives a friendly hello! /// /// Says \"Hello, [name]\" to the `Person` it is called on. pub fn hello(& self) { println!(\"Hello, {}!\", self.name); } }","title":"Doc Examples"},{"location":"#some-useful-cargo-plugins","text":"These add extra commands to cargo that make it even more useful! [ cargo-add ] - Add dependencies to your Cargo.toml without having to manually edit the file. console $ cargo install cargo-add --force Updating crates.io index Installing cargo-add v0.2.0 ... Finished release [optimized] target(s) in 14.65s Replacing /Users/reynn/.cargo/bin/cargo-add $ cargo add clap $ cargo add clap --version '~2.3'","title":"Some Useful Cargo plugins"},{"location":"#crates-libraries","text":"See [] for a complete run down of crates.","title":"Crates (Libraries)"},{"location":"best_practices/","text":"Best Practices Rustfmt Clippy Rustfmt Use of the rustfmt tool will alert you to any formatting errors, your commits should run this cleanly. Rustfmt is conveniently available as a Cargo subcommand. # Rustfmt is not included as a core piece of Cargo, we must install it first $ rustup add component rustfmt # Now that it is installed we can run it $ cargo fix # Basic command # Compiles the program, if no lint warnings exist no output $ cargo fix --allow-dirty --allow-staged # Run fix even if there are pending Git changes # Compiles the program, if no lint warnings exist no output Clippy Clippy is an additional linting tool that helps catch common mistakes. Clippy can also fix some of the mistakes automatically with the --fix flag. # Clippy is not included as a core piece of Cargo, we must install it first $ rustup add component clippy # Now that it is installed we can run it $ cargo clippy # Basic # Output will be any mistakes it finds or nothing if code is clean. $ cargo clippy -- --fix # Autofix mistakes # Output will be any mistakes it finds or nothing if code is clean.","title":"Best Practices"},{"location":"best_practices/#best-practices","text":"Rustfmt Clippy","title":"Best Practices "},{"location":"best_practices/#rustfmt","text":"Use of the rustfmt tool will alert you to any formatting errors, your commits should run this cleanly. Rustfmt is conveniently available as a Cargo subcommand. # Rustfmt is not included as a core piece of Cargo, we must install it first $ rustup add component rustfmt # Now that it is installed we can run it $ cargo fix # Basic command # Compiles the program, if no lint warnings exist no output $ cargo fix --allow-dirty --allow-staged # Run fix even if there are pending Git changes # Compiles the program, if no lint warnings exist no output","title":"Rustfmt"},{"location":"best_practices/#clippy","text":"Clippy is an additional linting tool that helps catch common mistakes. Clippy can also fix some of the mistakes automatically with the --fix flag. # Clippy is not included as a core piece of Cargo, we must install it first $ rustup add component clippy # Now that it is installed we can run it $ cargo clippy # Basic # Output will be any mistakes it finds or nothing if code is clean. $ cargo clippy -- --fix # Autofix mistakes # Output will be any mistakes it finds or nothing if code is clean.","title":"Clippy"},{"location":"cargo/","text":"Cargo Overview build test doc install Plugins Plugin Suggestions Cargo Add build test doc install Plugins Plugin Suggestions These add extra commands to cargo that make it even more useful! Cargo Add [ cargo-add ] - Add dependencies to your Cargo.toml without having to manually edit the file. console $ cargo install cargo-add --force Updating crates.io index Installing cargo-add v0.2.0 ... Finished release [optimized] target(s) in 14.65s Replacing /Users/reynn/.cargo/bin/cargo-add $ cargo add clap $ cargo add clap --version '~2.3'","title":"Cargo"},{"location":"cargo/#cargo-overview","text":"build test doc install Plugins Plugin Suggestions Cargo Add","title":"Cargo Overview "},{"location":"cargo/#build","text":"","title":"build"},{"location":"cargo/#test","text":"","title":"test"},{"location":"cargo/#doc","text":"","title":"doc"},{"location":"cargo/#install","text":"","title":"install"},{"location":"cargo/#plugins","text":"","title":"Plugins"},{"location":"cargo/#plugin-suggestions","text":"These add extra commands to cargo that make it even more useful!","title":"Plugin Suggestions"},{"location":"cargo/#cargo-add","text":"[ cargo-add ] - Add dependencies to your Cargo.toml without having to manually edit the file. console $ cargo install cargo-add --force Updating crates.io index Installing cargo-add v0.2.0 ... Finished release [optimized] target(s) in 14.65s Replacing /Users/reynn/.cargo/bin/cargo-add $ cargo add clap $ cargo add clap --version '~2.3'","title":"Cargo Add"},{"location":"crates/","text":"Rust Crates error_chain! Logging chrono clap serde reqwest error_chain! Documentation for error_chain can be found at docs.rs . Logging name crates.io docs.rs log simplelog fern env_logger chrono clap serde reqwest","title":"Crates"},{"location":"crates/#rust-crates","text":"error_chain! Logging chrono clap serde reqwest","title":"Rust Crates "},{"location":"crates/#error_chain","text":"Documentation for error_chain can be found at docs.rs .","title":"error_chain!"},{"location":"crates/#logging","text":"name crates.io docs.rs log simplelog fern env_logger","title":"Logging"},{"location":"crates/#chrono","text":"","title":"chrono"},{"location":"crates/#clap","text":"","title":"clap"},{"location":"crates/#serde","text":"","title":"serde"},{"location":"crates/#reqwest","text":"","title":"reqwest"},{"location":"features/","text":"Language Features Ownership and Borrowing Option and Result Lazy iterators Macros Declarative Macros Procedural Macros Enums Basic enum example Enum Variants Ownership and Borrowing [ Ownership Chapter ] Rust does not force you to manage memory directly using alloc and dealloc , it also does not use a Garbage collection system such as Java and Go. Instead when variables go out of scope they are cleaned up. fn main() { let x = 10; { // This is a closure and is a separate scope from the main func let y = 20; println!(\"x + y = {}\", (x + y)); } // This is the end of the closure, y will be unavailable after this println!(\"y is {}\", y); } When attempting to run this code you will get the following error $ cargo run Compiling rust-basic-app-template v0.1.0 (/Users/reynn/git/github.com/reynn/rust-basic-app-template) error[E0425]: cannot find value `y` in this scope --> src/main.rs:8:25 | 8 | println!(\"y is {}\", y); | ^ help: a local variable with a similar name exists: `x` error: aborting due to previous error For more information about this error, try `rustc --explain E0425`. error: could not compile `rust-basic-app-template`. To learn more, run the command again with --verbose. Option and Result [ Option Chapter ] [ Result Chapter ] A typical pattern in Go is to return a type + an error like shown in the following snippet // This function wont fail the program but still has to return an error type func add(a, b: int) (int, error) { if b < 0 || a < 0 { return 0, fmt.Error(\"Not going to add a negative number\") } return a + b } // This function could cause the app to fail if not successful which makes sense for an error func GetClient(auth *Authenticator) (*Client, error) { if auth == nil { return nil } // newClient is a method that initializes the client and ensures successful auth // signature is similar to this GetClient method return newClient(auth) } func main() { res, err := add(1, -5) if err != nil { fmt.Printf(\"Failed to add the numbers together %v\", err) } else { fmt.Printf(\"Result is %d\", res) } if client, cErr := GetClient(AnonAuth{}); err != { executeLoop(client) } else { panic(cErr) } } In Rust this is made easier by the Option and Result types. fn add(a: i32, b: i32) -> Option<i32> { Some(a+b) } fn get_client(auth: &Authenticator) -> Result<Client> { Ok(Client::new(auth)?) // shortcut, `?` will return out the error when the function returns a Result } // Result<()> is a void result, this is so you can still use the ? shortcut in main fn main() -> Result<()> { if let Some(res) = add(1, 80) { assert_eq!(res, 81); }; match get_client(auth::Anonymous()) { Ok(c) -> c.whoami()?, Err(e) -> { eprintln!(\"Error creating a new client {}\", e); std::process::exit(2); } } } Lazy iterators Similar to generators in Python where the call to .iter() just returns the option to retrieve next instead of actually getting the data. This can lead to reduction in API calls since paging doesn't have to happen up front. Some real examples from our existing responsibilities. Lookups to GitHub for teams can be sorted and once bh- teams no longer show in results we can stop calling the API since we wont care about the rest. Macros Macros provide a form of code generation to reduce boilerplate code. The earliest macro a new Rust dev will use is the println! macro. // This is provided as a convenient macro println!(\"Hello World\"); // The compilation will expand this macro to something like { $crate::io::_print(std::fmt::Arguments::new_v1(&[], &[])); } Declarative Macros [ Declarative Macros Chapter ] Declarative macros can be defined anywhere using the macro_rules! macro. This is a good candidate for basic code that must be reused in several places. Procedural Macros [ Procedural Macros Chapter ] Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. Enums Enums exist in a lot of languages but were not properly supported in Go. Rust expands on normal enums by having Enum variants as well. The [ Enum Chapter ] in the Rust book has a really good intro on enums and how to define variants but at a high level overview. Basic enum example /// Define a basic enum to switch between IP v4 and v6. enum AddressVersion { V4, V6, } struct IPAddress { version: AddressVersion, address: String, } impl IPAddress { fn new(address: String) -> Result<Self> { /// parse_version isn't defined here but the signature is /// parse_version(address: &str) -> Result(AddressVersion) if let Ok(address) = parse_version(address)? { Ok( Self { version, address, } ) } } } #[cfg(test)] mod address_tests { fn test_basic() { } } Enum Variants /// Simplify the basic example with a variant enum IPAddress { V4(String), V6(String), }","title":"Features"},{"location":"features/#language-features","text":"Ownership and Borrowing Option and Result Lazy iterators Macros Declarative Macros Procedural Macros Enums Basic enum example Enum Variants","title":"Language Features "},{"location":"features/#ownership-and-borrowing","text":"[ Ownership Chapter ] Rust does not force you to manage memory directly using alloc and dealloc , it also does not use a Garbage collection system such as Java and Go. Instead when variables go out of scope they are cleaned up. fn main() { let x = 10; { // This is a closure and is a separate scope from the main func let y = 20; println!(\"x + y = {}\", (x + y)); } // This is the end of the closure, y will be unavailable after this println!(\"y is {}\", y); } When attempting to run this code you will get the following error $ cargo run Compiling rust-basic-app-template v0.1.0 (/Users/reynn/git/github.com/reynn/rust-basic-app-template) error[E0425]: cannot find value `y` in this scope --> src/main.rs:8:25 | 8 | println!(\"y is {}\", y); | ^ help: a local variable with a similar name exists: `x` error: aborting due to previous error For more information about this error, try `rustc --explain E0425`. error: could not compile `rust-basic-app-template`. To learn more, run the command again with --verbose.","title":"Ownership and Borrowing"},{"location":"features/#option-and-result","text":"[ Option Chapter ] [ Result Chapter ] A typical pattern in Go is to return a type + an error like shown in the following snippet // This function wont fail the program but still has to return an error type func add(a, b: int) (int, error) { if b < 0 || a < 0 { return 0, fmt.Error(\"Not going to add a negative number\") } return a + b } // This function could cause the app to fail if not successful which makes sense for an error func GetClient(auth *Authenticator) (*Client, error) { if auth == nil { return nil } // newClient is a method that initializes the client and ensures successful auth // signature is similar to this GetClient method return newClient(auth) } func main() { res, err := add(1, -5) if err != nil { fmt.Printf(\"Failed to add the numbers together %v\", err) } else { fmt.Printf(\"Result is %d\", res) } if client, cErr := GetClient(AnonAuth{}); err != { executeLoop(client) } else { panic(cErr) } } In Rust this is made easier by the Option and Result types. fn add(a: i32, b: i32) -> Option<i32> { Some(a+b) } fn get_client(auth: &Authenticator) -> Result<Client> { Ok(Client::new(auth)?) // shortcut, `?` will return out the error when the function returns a Result } // Result<()> is a void result, this is so you can still use the ? shortcut in main fn main() -> Result<()> { if let Some(res) = add(1, 80) { assert_eq!(res, 81); }; match get_client(auth::Anonymous()) { Ok(c) -> c.whoami()?, Err(e) -> { eprintln!(\"Error creating a new client {}\", e); std::process::exit(2); } } }","title":"Option and Result"},{"location":"features/#lazy-iterators","text":"Similar to generators in Python where the call to .iter() just returns the option to retrieve next instead of actually getting the data. This can lead to reduction in API calls since paging doesn't have to happen up front. Some real examples from our existing responsibilities. Lookups to GitHub for teams can be sorted and once bh- teams no longer show in results we can stop calling the API since we wont care about the rest.","title":"Lazy iterators"},{"location":"features/#macros","text":"Macros provide a form of code generation to reduce boilerplate code. The earliest macro a new Rust dev will use is the println! macro. // This is provided as a convenient macro println!(\"Hello World\"); // The compilation will expand this macro to something like { $crate::io::_print(std::fmt::Arguments::new_v1(&[], &[])); }","title":"Macros"},{"location":"features/#declarative-macros","text":"[ Declarative Macros Chapter ] Declarative macros can be defined anywhere using the macro_rules! macro. This is a good candidate for basic code that must be reused in several places.","title":"Declarative Macros"},{"location":"features/#procedural-macros","text":"[ Procedural Macros Chapter ] Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.","title":"Procedural Macros"},{"location":"features/#enums","text":"Enums exist in a lot of languages but were not properly supported in Go. Rust expands on normal enums by having Enum variants as well. The [ Enum Chapter ] in the Rust book has a really good intro on enums and how to define variants but at a high level overview.","title":"Enums"},{"location":"features/#basic-enum-example","text":"/// Define a basic enum to switch between IP v4 and v6. enum AddressVersion { V4, V6, } struct IPAddress { version: AddressVersion, address: String, } impl IPAddress { fn new(address: String) -> Result<Self> { /// parse_version isn't defined here but the signature is /// parse_version(address: &str) -> Result(AddressVersion) if let Ok(address) = parse_version(address)? { Ok( Self { version, address, } ) } } } #[cfg(test)] mod address_tests { fn test_basic() { } }","title":"Basic enum example"},{"location":"features/#enum-variants","text":"/// Simplify the basic example with a variant enum IPAddress { V4(String), V6(String), }","title":"Enum Variants"},{"location":"patterns/","text":"Established Patterns Preludes Preludes Instead of importing each module individually a single module can function as a way to import multiple other modules at the same time. Example: /// As a library user you can use the following import (main.rs) use crate::prelude::*; /// In place of much larger list of imports (prelude.rs) pub use crate::{ auth::{AnonymousAuthenticator, TokenAuthenticator, AppAuthenticator}, client::GitHubClient, errors::APIError, traits::*, };","title":"Patterns"},{"location":"patterns/#established-patterns","text":"Preludes","title":"Established Patterns "},{"location":"patterns/#preludes","text":"Instead of importing each module individually a single module can function as a way to import multiple other modules at the same time. Example: /// As a library user you can use the following import (main.rs) use crate::prelude::*; /// In place of much larger list of imports (prelude.rs) pub use crate::{ auth::{AnonymousAuthenticator, TokenAuthenticator, AppAuthenticator}, client::GitHubClient, errors::APIError, traits::*, };","title":"Preludes"},{"location":"patterns/#_1","text":"","title":""}]}