<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Features - Rust for Delivery Architecture</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.1.2, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">Rust for Delivery Architecture</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="cargo/">
<a href="../cargo/">Cargo</a>
<li class="chapter" data-path="best_practices/">
<a href="../best_practices/">Best Practices</a>
<li class="chapter" data-path="crates/">
<a href="../crates/">Crates</a>
<li class="chapter active" data-path="features/">
<a href="./">Features</a>
<li class="chapter" data-path="patterns/">
<a href="../patterns/">Patterns</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="language-features">Language Features <!-- omit in toc --></h1>
<ul>
<li><a href="#ownership-and-borrowing">Ownership and Borrowing</a></li>
<li><a href="#option-and-result"><code>Option</code> and <code>Result</code></a></li>
<li><a href="#lazy-iterators">Lazy iterators</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#declarative-macros">Declarative Macros</a></li>
<li><a href="#procedural-macros">Procedural Macros</a></li>
<li><a href="#enums">Enums</a></li>
<li><a href="#basic-enum-example">Basic enum example</a></li>
<li><a href="#enum-variants">Enum Variants</a></li>
</ul>
<h2 id="ownership-and-borrowing">Ownership and Borrowing</h2>
<p>[<code>Ownership Chapter</code>]</p>
<p>Rust does not force you to manage memory directly using <code>alloc</code> and <code>dealloc</code>, it also does not use a
Garbage collection system such as Java and Go. Instead when variables go out of scope they are cleaned up.</p>
<pre><code class="rust">fn main() {
    let x = 10;
    { // This is a closure and is a separate scope from the main func
        let y = 20;
        println!(&quot;x + y = {}&quot;, (x + y));
    } // This is the end of the closure, y will be unavailable after this
    println!(&quot;y is {}&quot;, y);
}
</code></pre>

<p>When attempting to run this code you will get the following error</p>
<pre><code class="shell">$ cargo run
Compiling rust-basic-app-template v0.1.0 (/Users/reynn/git/github.com/reynn/rust-basic-app-template)
error[E0425]: cannot find value `y` in this scope
 --&gt; src/main.rs:8:25
  |
8 |     println!(&quot;y is {}&quot;, y);
  |                         ^ help: a local variable with a similar name exists: `x`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
error: could not compile `rust-basic-app-template`.

To learn more, run the command again with --verbose.
</code></pre>

<h2 id="option-and-result"><code>Option</code> and <code>Result</code></h2>
<p>[<code>Option Chapter</code>]</p>
<p>[<code>Result Chapter</code>]</p>
<p>A typical pattern in Go is to return a type + an error like shown in the following snippet</p>
<pre><code class="golang">// This function wont fail the program but still has to return an error type
func add(a, b: int) (int, error) {
    if b &lt; 0 || a &lt; 0 {
        return 0, fmt.Error(&quot;Not going to add a negative number&quot;)
    }
    return a + b
}

// This function could cause the app to fail if not successful which makes sense for an error
func GetClient(auth *Authenticator) (*Client, error) {
    if auth == nil {
        return nil
    }
    // newClient is a method that initializes the client and ensures successful auth
    // signature is similar to this GetClient method
    return newClient(auth)
}

func main() {
    res, err := add(1, -5)
    if err != nil {
        fmt.Printf(&quot;Failed to add the numbers together %v&quot;, err)
    } else {
        fmt.Printf(&quot;Result is %d&quot;, res)
    }

    if client, cErr := GetClient(AnonAuth{}); err != {
        executeLoop(client)
    } else {
        panic(cErr)
    }
}
</code></pre>

<p>In Rust this is made easier by the <code>Option</code> and <code>Result</code> types.</p>
<pre><code class="rust">fn add(a: i32, b: i32) -&gt; Option&lt;i32&gt; {
    Some(a+b)
}

fn get_client(auth: &amp;Authenticator) -&gt; Result&lt;Client&gt; {
    Ok(Client::new(auth)?) // shortcut, `?` will return out the error when the function returns a Result
}

// Result&lt;()&gt; is a void result, this is so you can still use the ? shortcut in main
fn main() -&gt; Result&lt;()&gt; {
    if let Some(res) = add(1, 80) {
        assert_eq!(res, 81);
    };

    match get_client(auth::Anonymous()) {
        Ok(c) -&gt; c.whoami()?,
        Err(e) -&gt; {
            eprintln!(&quot;Error creating a new client {}&quot;, e);
            std::process::exit(2);
        }
    }
}
</code></pre>

<h2 id="lazy-iterators">Lazy iterators</h2>
<p>Similar to generators in Python where the call to <code>.iter()</code> just returns the
option to retrieve next instead of actually getting the data.
This can lead to reduction in API calls since paging doesn't have to happen up front.</p>
<p>Some real examples from our existing responsibilities.
Lookups to GitHub for teams can be sorted and once <code>bh-</code> teams no longer show
in results we can stop calling the API since we wont care about the rest.</p>
<h2 id="macros">Macros</h2>
<p>Macros provide a form of code generation to reduce boilerplate code. The earliest 
macro a new Rust dev will use is the <code>println!</code> macro.</p>
<pre><code class="rust">// This is provided as a convenient macro
println!(&quot;Hello World&quot;);
// The compilation will expand this macro to something like
{
  $crate::io::_print(std::fmt::Arguments::new_v1(&amp;[], &amp;[]));
}
</code></pre>

<h3 id="declarative-macros">Declarative Macros</h3>
<p>[<code>Declarative Macros Chapter</code>]</p>
<p>Declarative macros can be defined anywhere using the <code>macro_rules!</code> macro.
This is a good candidate for basic code that must be reused in several places.</p>
<h3 id="procedural-macros">Procedural Macros</h3>
<p>[<code>Procedural Macros Chapter</code>]</p>
<p>Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</p>
<h2 id="enums">Enums</h2>
<p>Enums exist in a lot of languages but were not properly supported in Go.
Rust expands on normal enums by having Enum variants as well. The [<code>Enum Chapter</code>]
in the Rust book has a really good intro on enums and how to define variants
but at a high level overview.</p>
<h3 id="basic-enum-example">Basic enum example</h3>
<pre><code class="rust">/// Define a basic enum to switch between IP v4 and v6.
enum AddressVersion {
    V4,
    V6,
}
struct IPAddress {
    version: AddressVersion,
    address: String,
}
impl IPAddress {
    fn new(address: String) -&gt; Result&lt;Self&gt; {
        /// parse_version isn't defined here but the signature is
        /// parse_version(address: &amp;str) -&gt; Result(AddressVersion)
        if let Ok(address) = parse_version(address)? {
            Ok(
                Self {
                    version,
                    address,
                }
            )
        }
    }
}

#[cfg(test)]
mod address_tests {
    fn test_basic() {
    }
}
</code></pre>

<h3 id="enum-variants">Enum Variants</h3>
<pre><code class="rust">/// Simplify the basic example with a variant
enum IPAddress {
    V4(String),
    V6(String),
}
</code></pre>

<!-- Links below -->


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>