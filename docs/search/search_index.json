{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rust Resources \u00b6 Motivations \u00b6 Stumbles with Go \u00b6 Projects: support-clerk, mi6 lack of pre-defined project structures it was difficult to find one that lasted and made sense to everyone on the team. #1 also lead to difficulty in code management and maintenance go mod while initially a big win for the community, finally having a general package management tool has not gone as well as hoped and the syntax becomes difficult due to having gone with a custom DSL rather than a something more common like YAML/TOML/etc. Lack of some typical data structures in addition to lack of generics lead to lots of boilerplate that was being solved in ways that are not best practice. At least one library we were using has been broken randomly by the author changing the name. Go build is a very simple build tool so it only builds a single binary at a time. This leads to additional software to manage builds like Mage to effectively handle building for Serverless applications. Issues with Python \u00b6 Projects: herald, several other bot trials Deploy/Build methods Code being in production Lack of strict typing lead to many failures only discovered in production How Rust may help solve these problems \u00b6 cargo is the only package management tool and is heavily influenced by the community. It uses TOML which is a common data structure used in many cloud native software tools. cargo is the tool that can do basically everything, it is the software install tool like pip using cargo install exa for instance. It also handles testing, doc building, project initialization and much more as well as having plugin crates to extend functionality further. cargo and rust having a set structure also allows cargo to manage multiple binary builds on it\u2019s own by passing a --bins this will simplify the build process for us significantly. Stumbles we are likely to have with Rust \u00b6 Rust has a newer type of memory management called a [ Ownership ]. The concept seems easy at first but it is a hurdle that could take a few weeks for everyone to fully understand. The up side to this however is it allows compile time checks of memory management so that null pointers are rare occurrences in production. Learning materials \u00b6 Good places to get started learning Rust from the basics of installation to async programming and procedural macros. I highly recommend reading the official book through first. Official Book Online Official Book Kindle/Paperback Cargo Book Build a CLI app Sub Topics \u00b6 Setup Language Features Best Practices Testing Documentation Crates Cargo Reference Material \u00b6 These links will be more focused on places to quickly look up info including compiler errors and CLI commands. Rust By Example Compiler Error Index Rust Cheat Sheet","title":"Home"},{"location":"#rust-resources","text":"","title":"Rust Resources "},{"location":"#motivations","text":"","title":"Motivations"},{"location":"#stumbles-with-go","text":"Projects: support-clerk, mi6 lack of pre-defined project structures it was difficult to find one that lasted and made sense to everyone on the team. #1 also lead to difficulty in code management and maintenance go mod while initially a big win for the community, finally having a general package management tool has not gone as well as hoped and the syntax becomes difficult due to having gone with a custom DSL rather than a something more common like YAML/TOML/etc. Lack of some typical data structures in addition to lack of generics lead to lots of boilerplate that was being solved in ways that are not best practice. At least one library we were using has been broken randomly by the author changing the name. Go build is a very simple build tool so it only builds a single binary at a time. This leads to additional software to manage builds like Mage to effectively handle building for Serverless applications.","title":"Stumbles with Go"},{"location":"#issues-with-python","text":"Projects: herald, several other bot trials Deploy/Build methods Code being in production Lack of strict typing lead to many failures only discovered in production","title":"Issues with Python"},{"location":"#how-rust-may-help-solve-these-problems","text":"cargo is the only package management tool and is heavily influenced by the community. It uses TOML which is a common data structure used in many cloud native software tools. cargo is the tool that can do basically everything, it is the software install tool like pip using cargo install exa for instance. It also handles testing, doc building, project initialization and much more as well as having plugin crates to extend functionality further. cargo and rust having a set structure also allows cargo to manage multiple binary builds on it\u2019s own by passing a --bins this will simplify the build process for us significantly.","title":"How Rust may help solve these problems"},{"location":"#stumbles-we-are-likely-to-have-with-rust","text":"Rust has a newer type of memory management called a [ Ownership ]. The concept seems easy at first but it is a hurdle that could take a few weeks for everyone to fully understand. The up side to this however is it allows compile time checks of memory management so that null pointers are rare occurrences in production.","title":"Stumbles we are likely to have with Rust"},{"location":"#learning-materials","text":"Good places to get started learning Rust from the basics of installation to async programming and procedural macros. I highly recommend reading the official book through first. Official Book Online Official Book Kindle/Paperback Cargo Book Build a CLI app","title":"Learning materials"},{"location":"#sub-topics","text":"Setup Language Features Best Practices Testing Documentation Crates Cargo","title":"Sub Topics"},{"location":"#reference-material","text":"These links will be more focused on places to quickly look up info including compiler errors and CLI commands. Rust By Example Compiler Error Index Rust Cheat Sheet","title":"Reference Material"},{"location":"best_practices/","text":"Best Practices \u00b6 Tooling \u00b6 Between the official Rust and Cargo tooling and the amazing community involved with Rust there is a lot of tools written in Rust and for improving Rust quality. Try to get involved and see what you can find that work well and can improve the team workflow. Rustfmt \u00b6 Use of the rustfmt tool will alert you to any formatting errors, your commits should run this cleanly. Rustfmt is conveniently available as a Cargo subcommand. # Rustfmt is not included as a core piece of Cargo, we must install it first $ rustup add component rustfmt # this does install a binary for rustfmt, calling it with Rust is easier # Now that it is installed we can run it $ cargo fix # Basic command # Compiles the program, if no lint warnings exist no output $ cargo fix --allow-dirty --allow-staged # Run fix even if there are pending Git changes # Compiles the program, if no lint warnings exist no output Clippy \u00b6 Clippy is an additional linting tool that helps catch common mistakes. Clippy can also fix some of the mistakes automatically with the --fix flag. # Clippy is not included as a core piece of Cargo, we must install it first $ rustup add component clippy # Now that it is installed we can run it $ cargo clippy # Basic # Output will be any mistakes it finds or nothing if code is clean. $ cargo clippy -- --fix # Autofix mistakes # Output will be any mistakes it finds or nothing if code is clean. Coding style \u00b6 Generally speaking follow guidelines for naming and coding styles from the API Guidelines page. Use preludes when possible \u00b6 Many Rust crates provided a convenient import option called preludes . For instance when working with IO you can import std::io::prelude::*; rather than importing the following: std::io::{BufRead,Read,Seek,Write}; . Anyone can implement preludes as a way to simplify imports. Use Expressions \u00b6 A typical thing we see in some code bases for setting a variable to something based on a different variable looks like this: // syntax highlighting is for Groovy but this is typical of various languages def e; if a { e = \"hello\"; } else { e = \"world\"; } // or def server_list = ansible.get_hosts(); def server; for (s in server_list) { if (s.name == 'expected_host') { server = s; break; } } In Rust it is preferred to use the following: let e = if a { \"hello\" } else { \"world\" }; // or let server_list = ansible::get_hosts_from_inventory(\"$HOME/inventory.yaml\"); let server: Server = server_list .iter() .filter(|x| x.name == \"expected_host\") .first(); Iterators over loops \u00b6 We often have to call APIs or similar tasks that may fail and use a loop to set a variable. // here we are getting a list of results from GitHub // and creating a list if we want to use them def allRepos = github.get_repo_list() def requestedRepos = [] for (repo in allRepos) { if (repo.name.startswith('hello')) { requestedRepos.add(repo) } } let requested_repos = github.get_repo_list() .iter() .filter(|x| x.name.starts_with(\"hello\")) .collect::<Vec<_>>(); Enums over boolean or ints \u00b6 Enums are a more expressive way of handling multiple cases and help with readability. fn http_get(url: &str) -> Result<&str> { let response = http::request(http::method::GET, url)?; match response.status { http::status::Ok(resp) => Ok(resp.body), http::status::Forbidden(resp) => Err(ErrorKind::RequestFailed(resp.body)), } } Handle Option and Result with ? \u00b6 Adjust code to return a Result even if it is a Void result. This allows changing fn main() { let _conf_file = std::fs::read_to_string(\"config.yaml\").unwrap(\"failed to load file\"); println!(\"Successfully loaded config file\"); } // // TO // fn main() -> Result<()> { // () is our void return type // The error from read_to_string will bubble up to the Result by using `?` let _conf_file = std::fs::read_to_string(\"config.yaml\")?; println!(\"Successfully loaded config file\"); } Avoid unsafe! code \u00b6 Unsafe code is rarely needed and the memory implications require considerable resources to verify. If an external crate uses it and has a valid reason it can be considered if it has sufficient testing and documentation however as a general rule we should try to find an alternate crate. Implement traits \u00b6 As a general rule you should implement the following traits: Debug Display","title":"Best Practices"},{"location":"best_practices/#best-practices","text":"","title":"Best Practices "},{"location":"best_practices/#tooling","text":"Between the official Rust and Cargo tooling and the amazing community involved with Rust there is a lot of tools written in Rust and for improving Rust quality. Try to get involved and see what you can find that work well and can improve the team workflow.","title":"Tooling"},{"location":"best_practices/#rustfmt","text":"Use of the rustfmt tool will alert you to any formatting errors, your commits should run this cleanly. Rustfmt is conveniently available as a Cargo subcommand. # Rustfmt is not included as a core piece of Cargo, we must install it first $ rustup add component rustfmt # this does install a binary for rustfmt, calling it with Rust is easier # Now that it is installed we can run it $ cargo fix # Basic command # Compiles the program, if no lint warnings exist no output $ cargo fix --allow-dirty --allow-staged # Run fix even if there are pending Git changes # Compiles the program, if no lint warnings exist no output","title":"Rustfmt"},{"location":"best_practices/#clippy","text":"Clippy is an additional linting tool that helps catch common mistakes. Clippy can also fix some of the mistakes automatically with the --fix flag. # Clippy is not included as a core piece of Cargo, we must install it first $ rustup add component clippy # Now that it is installed we can run it $ cargo clippy # Basic # Output will be any mistakes it finds or nothing if code is clean. $ cargo clippy -- --fix # Autofix mistakes # Output will be any mistakes it finds or nothing if code is clean.","title":"Clippy"},{"location":"best_practices/#coding-style","text":"Generally speaking follow guidelines for naming and coding styles from the API Guidelines page.","title":"Coding style"},{"location":"best_practices/#use-preludes-when-possible","text":"Many Rust crates provided a convenient import option called preludes . For instance when working with IO you can import std::io::prelude::*; rather than importing the following: std::io::{BufRead,Read,Seek,Write}; . Anyone can implement preludes as a way to simplify imports.","title":"Use preludes when possible"},{"location":"best_practices/#use-expressions","text":"A typical thing we see in some code bases for setting a variable to something based on a different variable looks like this: // syntax highlighting is for Groovy but this is typical of various languages def e; if a { e = \"hello\"; } else { e = \"world\"; } // or def server_list = ansible.get_hosts(); def server; for (s in server_list) { if (s.name == 'expected_host') { server = s; break; } } In Rust it is preferred to use the following: let e = if a { \"hello\" } else { \"world\" }; // or let server_list = ansible::get_hosts_from_inventory(\"$HOME/inventory.yaml\"); let server: Server = server_list .iter() .filter(|x| x.name == \"expected_host\") .first();","title":"Use Expressions"},{"location":"best_practices/#iterators-over-loops","text":"We often have to call APIs or similar tasks that may fail and use a loop to set a variable. // here we are getting a list of results from GitHub // and creating a list if we want to use them def allRepos = github.get_repo_list() def requestedRepos = [] for (repo in allRepos) { if (repo.name.startswith('hello')) { requestedRepos.add(repo) } } let requested_repos = github.get_repo_list() .iter() .filter(|x| x.name.starts_with(\"hello\")) .collect::<Vec<_>>();","title":"Iterators over loops"},{"location":"best_practices/#enums-over-boolean-or-ints","text":"Enums are a more expressive way of handling multiple cases and help with readability. fn http_get(url: &str) -> Result<&str> { let response = http::request(http::method::GET, url)?; match response.status { http::status::Ok(resp) => Ok(resp.body), http::status::Forbidden(resp) => Err(ErrorKind::RequestFailed(resp.body)), } }","title":"Enums over boolean or ints"},{"location":"best_practices/#handle-option-and-result-with","text":"Adjust code to return a Result even if it is a Void result. This allows changing fn main() { let _conf_file = std::fs::read_to_string(\"config.yaml\").unwrap(\"failed to load file\"); println!(\"Successfully loaded config file\"); } // // TO // fn main() -> Result<()> { // () is our void return type // The error from read_to_string will bubble up to the Result by using `?` let _conf_file = std::fs::read_to_string(\"config.yaml\")?; println!(\"Successfully loaded config file\"); }","title":"Handle Option and Result with ?"},{"location":"best_practices/#avoid-unsafe-code","text":"Unsafe code is rarely needed and the memory implications require considerable resources to verify. If an external crate uses it and has a valid reason it can be considered if it has sufficient testing and documentation however as a general rule we should try to find an alternate crate.","title":"Avoid unsafe! code"},{"location":"best_practices/#implement-traits","text":"As a general rule you should implement the following traits: Debug Display","title":"Implement traits"},{"location":"cargo/","text":"Cargo Overview \u00b6 build test doc install Plugins Plugin Suggestions Cargo Add build \u00b6 test \u00b6 doc \u00b6 install \u00b6 Plugins \u00b6 Plugin Suggestions \u00b6 These add extra commands to cargo that make it even more useful! Cargo Add \u00b6 [ cargo-edit ] - Add dependencies to your Cargo.toml without having to manually edit the file. console $ cargo install cargo-edit Updating crates.io index Installing cargo-add v0.2.0 ... Finished release [optimized] target(s) in 14.65s Replacing /Users/reynn/.cargo/bin/cargo-add $ cargo add clap $ cargo rm serde_json [ cargo-generate ] - Kickstart a project by using an existing git repo as a template. a list of available templates is available on the [ cargo-generate GitHub ] console $ cargo install cargo-generate Updating crates.io index Installing cargo-generate v0.5.0 ... Finished release [optimized] target(s) in 3m 40s Installing C:\\Users\\arasu\\.cargo\\bin\\cargo-generate.exe Installed package `cargo-generate v0.5.0` (executable `cargo-generate.exe`) $ cargo generate --git https://github.com/mendelt/cmdr-template Project Name: test-project Creating project called `test-project`... Done! New project created ~/git/test-project","title":"Cargo"},{"location":"cargo/#cargo-overview","text":"build test doc install Plugins Plugin Suggestions Cargo Add","title":"Cargo Overview "},{"location":"cargo/#build","text":"","title":"build"},{"location":"cargo/#test","text":"","title":"test"},{"location":"cargo/#doc","text":"","title":"doc"},{"location":"cargo/#install","text":"","title":"install"},{"location":"cargo/#plugins","text":"","title":"Plugins"},{"location":"cargo/#plugin-suggestions","text":"These add extra commands to cargo that make it even more useful!","title":"Plugin Suggestions"},{"location":"cargo/#cargo-add","text":"[ cargo-edit ] - Add dependencies to your Cargo.toml without having to manually edit the file. console $ cargo install cargo-edit Updating crates.io index Installing cargo-add v0.2.0 ... Finished release [optimized] target(s) in 14.65s Replacing /Users/reynn/.cargo/bin/cargo-add $ cargo add clap $ cargo rm serde_json [ cargo-generate ] - Kickstart a project by using an existing git repo as a template. a list of available templates is available on the [ cargo-generate GitHub ] console $ cargo install cargo-generate Updating crates.io index Installing cargo-generate v0.5.0 ... Finished release [optimized] target(s) in 3m 40s Installing C:\\Users\\arasu\\.cargo\\bin\\cargo-generate.exe Installed package `cargo-generate v0.5.0` (executable `cargo-generate.exe`) $ cargo generate --git https://github.com/mendelt/cmdr-template Project Name: test-project Creating project called `test-project`... Done! New project created ~/git/test-project","title":"Cargo Add"},{"location":"crates/","text":"Rust Crates \u00b6 Error Handling \u00b6 Error Chain \u00b6 Documentation for error_chain can be found at docs.rs . Error chain is designed to simplify error handling by providing a simplified Result enum as well as bail! and ensure! macros. Error chain is part of the Rust nursery, this means there is a chance of it being included in future official releases. Anyhow \u00b6 Anyhow provides a simpler API compared to error-chain by leaving custom error handling to the developer. Where error_chain uses a macro to override the default std::result::Result anyhow provides its own version of Result Anyhow is likely going to be used with another library like thiserror that provides a wrapper around the std::error::Error trait Logging \u00b6 name crates.io docs.rs log simplelog fern env_logger In a project you would use the log crate always and one of the others in conjunction. log crate provides the macro to send a log event at a specific level. The other crates provide the way to output the calls to log . chrono \u00b6 Chrono is a date time library that improves on the std::time crate. Most important distinction is being time zone aware by default. clap \u00b6 Clap is used to build CLI programs. Primarily it handles parsing of arguments and mapping to a struct. Clap 3 is in beta, we should use that instead of 2.3x since the differences between them are huge and retrofitting later doesn\u2019t make sense. serde \u00b6 Serde provides an interface between data structures. It doesn\u2019t do any of the parsing itself but provides a common interface for others to build on. We will likely use the following crates to actual handle the parsing: Format Crate TOML YAML JSON reqwest \u00b6 Reqwest is an HTTP Client for making requests to an external HTTP service. Reqwest is built on the Hyper crate that offers low level implementations of HTTP Client and Servers. warp \u00b6 Warp is a HTTP Server built on Hyper .","title":"Crates"},{"location":"crates/#rust-crates","text":"","title":"Rust Crates "},{"location":"crates/#error-handling","text":"","title":"Error Handling"},{"location":"crates/#error-chain","text":"Documentation for error_chain can be found at docs.rs . Error chain is designed to simplify error handling by providing a simplified Result enum as well as bail! and ensure! macros. Error chain is part of the Rust nursery, this means there is a chance of it being included in future official releases.","title":"Error Chain"},{"location":"crates/#anyhow","text":"Anyhow provides a simpler API compared to error-chain by leaving custom error handling to the developer. Where error_chain uses a macro to override the default std::result::Result anyhow provides its own version of Result Anyhow is likely going to be used with another library like thiserror that provides a wrapper around the std::error::Error trait","title":"Anyhow"},{"location":"crates/#logging","text":"name crates.io docs.rs log simplelog fern env_logger In a project you would use the log crate always and one of the others in conjunction. log crate provides the macro to send a log event at a specific level. The other crates provide the way to output the calls to log .","title":"Logging"},{"location":"crates/#chrono","text":"Chrono is a date time library that improves on the std::time crate. Most important distinction is being time zone aware by default.","title":"chrono"},{"location":"crates/#clap","text":"Clap is used to build CLI programs. Primarily it handles parsing of arguments and mapping to a struct. Clap 3 is in beta, we should use that instead of 2.3x since the differences between them are huge and retrofitting later doesn\u2019t make sense.","title":"clap"},{"location":"crates/#serde","text":"Serde provides an interface between data structures. It doesn\u2019t do any of the parsing itself but provides a common interface for others to build on. We will likely use the following crates to actual handle the parsing: Format Crate TOML YAML JSON","title":"serde"},{"location":"crates/#reqwest","text":"Reqwest is an HTTP Client for making requests to an external HTTP service. Reqwest is built on the Hyper crate that offers low level implementations of HTTP Client and Servers.","title":"reqwest"},{"location":"crates/#warp","text":"Warp is a HTTP Server built on Hyper .","title":"warp"},{"location":"documentation/","text":"Documentation \u00b6 Overview \u00b6 Rust provides a full markdown engine for code documentation using a /// block. In you can document the crate and submodules with markdown using //! that summarizes usage of the crate or module. References \u00b6 Rust By Example - Documentation Examples \u00b6 /// A human being is represented here pub struct Person { /// A person must have a name, no matter how much Juliet may hate it name: String, } impl Person { /// Returns a person with the name given them /// /// # Arguments /// /// * `name` - A string slice that holds the name of the person /// /// # Example /// /// ``` /// // You can have rust code between fences inside the comments /// // If you pass --test to Rustdoc, it will even test it for you! /// use doc::Person; /// let person = Person::new(\"name\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// Gives a friendly hello! /// /// Says \"Hello, [name]\" to the `Person` it is called on. pub fn hello(& self) { println!(\"Hello, {}!\", self.name); } }","title":"Documentation"},{"location":"documentation/#documentation","text":"","title":"Documentation "},{"location":"documentation/#overview","text":"Rust provides a full markdown engine for code documentation using a /// block. In you can document the crate and submodules with markdown using //! that summarizes usage of the crate or module.","title":"Overview"},{"location":"documentation/#references","text":"Rust By Example - Documentation","title":"References"},{"location":"documentation/#examples","text":"/// A human being is represented here pub struct Person { /// A person must have a name, no matter how much Juliet may hate it name: String, } impl Person { /// Returns a person with the name given them /// /// # Arguments /// /// * `name` - A string slice that holds the name of the person /// /// # Example /// /// ``` /// // You can have rust code between fences inside the comments /// // If you pass --test to Rustdoc, it will even test it for you! /// use doc::Person; /// let person = Person::new(\"name\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// Gives a friendly hello! /// /// Says \"Hello, [name]\" to the `Person` it is called on. pub fn hello(& self) { println!(\"Hello, {}!\", self.name); } }","title":"Examples"},{"location":"features/","text":"Language Features \u00b6 Ownership and Borrowing \u00b6 Ownership Chapter Rust does not force you to manage memory directly using alloc and dealloc , it also does not use a Garbage collection system such as Java and Go. Instead when variables go out of scope they are cleaned up. fn main() { let x = 10; { // This is a closure and is a separate scope from the main func let y = 20; println!(\"x + y = {}\", (x + y)); } // This is the end of the closure, y will be unavailable after this println!(\"y is {}\", y); } When attempting to run this code you will get the following error $ cargo run Compiling rust-basic-app-template v0.1.0 (/Users/reynn/git/github.com/reynn/rust-basic-app-template) error[E0425]: cannot find value `y` in this scope --> src/main.rs:8:25 | 8 | println!(\"y is {}\", y); | ^ help: a local variable with a similar name exists: `x` error: aborting due to previous error For more information about this error, try `rustc --explain E0425`. error: could not compile `rust-basic-app-template`. To learn more, run the command again with --verbose. Option and Result \u00b6 Option Chapter Result Chapter A typical pattern in Go is to return a type + an error like shown in the following snippet // This function wont fail the program but still has to return an error type func add(a, b: int) (int, error) { if b < 0 || a < 0 { return 0, fmt.Error(\"Not going to add a negative number\") } return a + b } // This function could cause the app to fail if not successful which makes sense for an error func GetClient(auth *Authenticator) (*Client, error) { if auth == nil { return nil } // newClient is a method that initializes the client and ensures successful auth // signature is similar to this GetClient method return newClient(auth) } func main() { res, err := add(1, -5) if err != nil { fmt.Printf(\"Failed to add the numbers together %v\", err) } else { fmt.Printf(\"Result is %d\", res) } if client, cErr := GetClient(AnonAuth{}); err != { executeLoop(client) } else { panic(cErr) } } In Rust this is made easier by the Option and Result types. fn add(a: i32, b: i32) -> Option<i32> { Some(a+b) } fn get_client(auth: &Authenticator) -> Result<Client> { Ok(Client::new(auth)?) // shortcut, `?` will return out the error when the function returns a Result } // Result<()> is a void result, this is so you can still use the ? shortcut in main fn main() -> Result<()> { if let Some(res) = add(1, 80) { assert_eq!(res, 81); }; match get_client(auth::Anonymous()) { Ok(c) -> c.whoami()?, Err(e) -> { eprintln!(\"Error creating a new client {}\", e); std::process::exit(2); } } } Lazy iterators \u00b6 Similar to generators in Python where the call to .iter() just returns the option to retrieve next instead of actually getting the data. This can lead to reduction in API calls since paging doesn\u2019t have to happen up front. Some real examples from our existing responsibilities. Lookups to GitHub for teams can be sorted and once bh- teams no longer show in results we can stop calling the API since we wont care about the rest. Macros \u00b6 Macros provide a form of code generation to reduce boilerplate code. The earliest macro a new Rust dev will use is the println! macro. // This is provided as a convenient macro println!(\"Hello World\"); // The compilation will expand this macro to something like { $crate::io::_print(std::fmt::Arguments::new_v1(&[], &[])); } Declarative Macros \u00b6 Declarative Macros Chapter Declarative macros can be defined anywhere using the macro_rules! macro. This is a good candidate for basic code that must be reused in several places. Procedural Macros \u00b6 Procedural Macros Chapter Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. Enums \u00b6 Enums exist in a lot of languages but were not properly supported in Go. Rust expands on normal enums by having Enum variants as well. The Enum Chapter in the Rust book has a really good intro on enums and how to define variants but at a high level overview. Basic enum example \u00b6 /// Define a basic enum to switch between IP v4 and v6. enum AddressVersion { V4, V6, } struct IPAddress { version: AddressVersion, address: String, } impl IPAddress { fn new(address: String) -> Result<Self> { /// parse_version isn't defined here but the signature is /// parse_version(address: &str) -> Result(AddressVersion) if let Ok(address) = parse_version(address)? { Ok( Self { version, address, } ) } } } #[cfg(test)] mod address_tests { fn test_basic() { } } Enum Variants \u00b6 /// Simplify the basic example with a variant enum IPAddress { V4(String), V6(String), }","title":"Language Features"},{"location":"features/#language-features","text":"","title":"Language Features "},{"location":"features/#ownership-and-borrowing","text":"Ownership Chapter Rust does not force you to manage memory directly using alloc and dealloc , it also does not use a Garbage collection system such as Java and Go. Instead when variables go out of scope they are cleaned up. fn main() { let x = 10; { // This is a closure and is a separate scope from the main func let y = 20; println!(\"x + y = {}\", (x + y)); } // This is the end of the closure, y will be unavailable after this println!(\"y is {}\", y); } When attempting to run this code you will get the following error $ cargo run Compiling rust-basic-app-template v0.1.0 (/Users/reynn/git/github.com/reynn/rust-basic-app-template) error[E0425]: cannot find value `y` in this scope --> src/main.rs:8:25 | 8 | println!(\"y is {}\", y); | ^ help: a local variable with a similar name exists: `x` error: aborting due to previous error For more information about this error, try `rustc --explain E0425`. error: could not compile `rust-basic-app-template`. To learn more, run the command again with --verbose.","title":"Ownership and Borrowing"},{"location":"features/#option-and-result","text":"Option Chapter Result Chapter A typical pattern in Go is to return a type + an error like shown in the following snippet // This function wont fail the program but still has to return an error type func add(a, b: int) (int, error) { if b < 0 || a < 0 { return 0, fmt.Error(\"Not going to add a negative number\") } return a + b } // This function could cause the app to fail if not successful which makes sense for an error func GetClient(auth *Authenticator) (*Client, error) { if auth == nil { return nil } // newClient is a method that initializes the client and ensures successful auth // signature is similar to this GetClient method return newClient(auth) } func main() { res, err := add(1, -5) if err != nil { fmt.Printf(\"Failed to add the numbers together %v\", err) } else { fmt.Printf(\"Result is %d\", res) } if client, cErr := GetClient(AnonAuth{}); err != { executeLoop(client) } else { panic(cErr) } } In Rust this is made easier by the Option and Result types. fn add(a: i32, b: i32) -> Option<i32> { Some(a+b) } fn get_client(auth: &Authenticator) -> Result<Client> { Ok(Client::new(auth)?) // shortcut, `?` will return out the error when the function returns a Result } // Result<()> is a void result, this is so you can still use the ? shortcut in main fn main() -> Result<()> { if let Some(res) = add(1, 80) { assert_eq!(res, 81); }; match get_client(auth::Anonymous()) { Ok(c) -> c.whoami()?, Err(e) -> { eprintln!(\"Error creating a new client {}\", e); std::process::exit(2); } } }","title":"Option and Result"},{"location":"features/#lazy-iterators","text":"Similar to generators in Python where the call to .iter() just returns the option to retrieve next instead of actually getting the data. This can lead to reduction in API calls since paging doesn\u2019t have to happen up front. Some real examples from our existing responsibilities. Lookups to GitHub for teams can be sorted and once bh- teams no longer show in results we can stop calling the API since we wont care about the rest.","title":"Lazy iterators"},{"location":"features/#macros","text":"Macros provide a form of code generation to reduce boilerplate code. The earliest macro a new Rust dev will use is the println! macro. // This is provided as a convenient macro println!(\"Hello World\"); // The compilation will expand this macro to something like { $crate::io::_print(std::fmt::Arguments::new_v1(&[], &[])); }","title":"Macros"},{"location":"features/#declarative-macros","text":"Declarative Macros Chapter Declarative macros can be defined anywhere using the macro_rules! macro. This is a good candidate for basic code that must be reused in several places.","title":"Declarative Macros"},{"location":"features/#procedural-macros","text":"Procedural Macros Chapter Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.","title":"Procedural Macros"},{"location":"features/#enums","text":"Enums exist in a lot of languages but were not properly supported in Go. Rust expands on normal enums by having Enum variants as well. The Enum Chapter in the Rust book has a really good intro on enums and how to define variants but at a high level overview.","title":"Enums"},{"location":"features/#basic-enum-example","text":"/// Define a basic enum to switch between IP v4 and v6. enum AddressVersion { V4, V6, } struct IPAddress { version: AddressVersion, address: String, } impl IPAddress { fn new(address: String) -> Result<Self> { /// parse_version isn't defined here but the signature is /// parse_version(address: &str) -> Result(AddressVersion) if let Ok(address) = parse_version(address)? { Ok( Self { version, address, } ) } } } #[cfg(test)] mod address_tests { fn test_basic() { } }","title":"Basic enum example"},{"location":"features/#enum-variants","text":"/// Simplify the basic example with a variant enum IPAddress { V4(String), V6(String), }","title":"Enum Variants"},{"location":"testing/","text":"Testing \u00b6 Rust gives a few ways to do testing including typical unit and integration testing as well as a great doc testing feature. Rust By Example - Testing Code example \u00b6 /// A human being is represented here pub struct Person { /// A person must have a name, no matter how much Juliet may hate it name: String, } impl Person { /// Returns a person with the name given them /// /// # Arguments /// /// * `name` - A string slice that holds the name of the person /// /// # Example /// /// ``` /// // You can have rust code between fences inside the comments /// // If you pass --test to Rustdoc, it will even test it for you! /// use doc::Person; /// let person = Person::new(\"name\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// Gives a friendly hello! /// /// Says \"Hello, [name]\" to the `Person` it is called on. pub fn hello(&self) { println!(\"Hello, {}!\", self.name); } } Unit Testing \u00b6 Unit testing will live right beside the code in a testing submodule. These should be quick tests that can be mocked and are very focused on a specific function and its inputs/outputs. These help ensure the small things continue doing as we expect. These should include tests for any private methods/functions as well. Integration testing \u00b6 Integration testing in the Rust specific context is focused around a modules inputs and outputs rather than specific functions. Documentation testing \u00b6 Examples \u00b6 Benchmarking \u00b6","title":"Testing"},{"location":"testing/#testing","text":"Rust gives a few ways to do testing including typical unit and integration testing as well as a great doc testing feature. Rust By Example - Testing","title":"Testing "},{"location":"testing/#code-example","text":"/// A human being is represented here pub struct Person { /// A person must have a name, no matter how much Juliet may hate it name: String, } impl Person { /// Returns a person with the name given them /// /// # Arguments /// /// * `name` - A string slice that holds the name of the person /// /// # Example /// /// ``` /// // You can have rust code between fences inside the comments /// // If you pass --test to Rustdoc, it will even test it for you! /// use doc::Person; /// let person = Person::new(\"name\"); /// ``` pub fn new(name: &str) -> Person { Person { name: name.to_string(), } } /// Gives a friendly hello! /// /// Says \"Hello, [name]\" to the `Person` it is called on. pub fn hello(&self) { println!(\"Hello, {}!\", self.name); } }","title":"Code example"},{"location":"testing/#unit-testing","text":"Unit testing will live right beside the code in a testing submodule. These should be quick tests that can be mocked and are very focused on a specific function and its inputs/outputs. These help ensure the small things continue doing as we expect. These should include tests for any private methods/functions as well.","title":"Unit Testing"},{"location":"testing/#integration-testing","text":"Integration testing in the Rust specific context is focused around a modules inputs and outputs rather than specific functions.","title":"Integration testing"},{"location":"testing/#documentation-testing","text":"","title":"Documentation testing"},{"location":"testing/#examples","text":"","title":"Examples"},{"location":"testing/#benchmarking","text":"","title":"Benchmarking"},{"location":"setup/general/","text":"Setting up for Rust Development \u00b6 Install Rust and Cargo Setup your IDE of choice Install Rust and Cargo \u00b6 Best way to bootstrap your development is using Rustup . $ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh info: downloading installer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. ... default host triple: x86_64-unknown-linux-gnu default toolchain: stable profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Select 1 to proceed, customizing provides options to download nightly/beta releases amongst other things. We do not need those right now. Once this completes and you are back at a prompt we will go ahead and get clippy and rustfmt installed. # Launch a new shell or run `source $HOME/.cargo/env` to have cargo in our path $ rustup component add rustfmt clippy Thats it! You are now ready to write and execute Rust code. Setup your IDE of choice \u00b6 IDE Installation Rust Config Visual Studio Code code.visualstudio.com Setup Vim vim.org Setup NeoVim vim.org Setup","title":"General"},{"location":"setup/general/#setting-up-for-rust-development","text":"Install Rust and Cargo Setup your IDE of choice","title":"Setting up for Rust Development "},{"location":"setup/general/#install-rust-and-cargo","text":"Best way to bootstrap your development is using Rustup . $ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh info: downloading installer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. ... default host triple: x86_64-unknown-linux-gnu default toolchain: stable profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation Select 1 to proceed, customizing provides options to download nightly/beta releases amongst other things. We do not need those right now. Once this completes and you are back at a prompt we will go ahead and get clippy and rustfmt installed. # Launch a new shell or run `source $HOME/.cargo/env` to have cargo in our path $ rustup component add rustfmt clippy Thats it! You are now ready to write and execute Rust code.","title":"Install Rust and Cargo"},{"location":"setup/general/#setup-your-ide-of-choice","text":"IDE Installation Rust Config Visual Studio Code code.visualstudio.com Setup Vim vim.org Setup NeoVim vim.org Setup","title":"Setup your IDE of choice"},{"location":"setup/vim/","text":"Vim/NVim \u00b6 Conquer of Completion (CoC) Vim Plug CoC CoC Extensions SpaceVim Other Vim plugin suggestions Conquer of Completion (CoC) \u00b6 CoC is an autocomplete engine that uses Language Servers to provide completions for many languages. Vim Plug \u00b6 First step is to install CoC using Vim Plug or any other plugin manager. VimPlug Setup $ curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim Once vim-plug exists in the autoload directory it can start managing plugins. CoC \u00b6 CoC Setup With Vim Plug installed it is just a matter of adding the CoC plugin and its keybindings. \" Specify a directory for plugins \" - For Neovim: stdpath('data') . '/plugged' \" - Avoid using standard Vim directory names like 'plugin' call plug#begin('~/.vim/plugged') \" Use release branch (Recommend) Plug 'neoclide/coc.nvim', {'branch': 'release'} \" Initialize plugin system call plug#end() Save this in your ~/.vimrc or init.vim file. In a new shell run the command vim -c 'PlugInstall | qall . This will install our plugins and quit. Now we can open a new vim instance and have CoC enabled. I would suggest using the example config to get started and customize as you need. CoC Extensions \u00b6 Extensions overview Extensions add functionality to CoC such as interacting with Language servers over LSP. I suggest adding any extensions you want to use to g:coc_global_extensions in your .vimrc or init.vim file. let g:coc_global_extensions = ['coc-actions', 'coc-rust-analyzer', 'coc-json', 'coc-yank'] SpaceVim \u00b6 SpaceVim is a complete Vim configuration. Read through the documentation provided by spacevim for full overview of how to best use it. GitHub Page Setup as Rust IDE Other Vim plugin suggestions \u00b6 Name Description Recover.vim Show a diff of the swap file before loading ctrlp.vim Fuzzy finding of files, buffers and more editorconfig-vim Use of .editorconfig files to set indentation etc vim-easy-align Handle aligning text vim-sayonara Deletes the buffer and handles windows more intelligently vim-fugitive Extensive Git integration added to Vim vim-repeat Beef up the default . repeater vim-rhubarb Add fancy extras for GitHub to the vim-fugitive plugin vim-which-key Keybinding manager nerdtree-git-plugin Add git information to NerdTree vim-gitgutter Show git changes in margin of file buffer vim-matchup Highlight, navigate and operate on sets of matching text vim-rainbow Colorize tabs, parens to make them easier to see lightline.vim Adds a powerline like status bar at the bottom vim-highlightedyank Highlights line after y is pressed tabman.vim Simple management of tabs in Vim nerdtree File Explorer tab vim-session Extended session management for Vim papercolor-theme Light theme gruvbox Configurable dark mode theme dracula Configurable dark mode theme fzf Fuzzy finding inside Vim/NVim fzf.vim Additional Vim setup for FZF vim-markdown-toc Manage ToC sections for Markdown files vim-toml Add support for TOML files","title":"Vim/NeoVim"},{"location":"setup/vim/#vimnvim","text":"Conquer of Completion (CoC) Vim Plug CoC CoC Extensions SpaceVim Other Vim plugin suggestions","title":"Vim/NVim "},{"location":"setup/vim/#conquer-of-completion-coc","text":"CoC is an autocomplete engine that uses Language Servers to provide completions for many languages.","title":"Conquer of Completion (CoC)"},{"location":"setup/vim/#vim-plug","text":"First step is to install CoC using Vim Plug or any other plugin manager. VimPlug Setup $ curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim Once vim-plug exists in the autoload directory it can start managing plugins.","title":"Vim Plug"},{"location":"setup/vim/#coc","text":"CoC Setup With Vim Plug installed it is just a matter of adding the CoC plugin and its keybindings. \" Specify a directory for plugins \" - For Neovim: stdpath('data') . '/plugged' \" - Avoid using standard Vim directory names like 'plugin' call plug#begin('~/.vim/plugged') \" Use release branch (Recommend) Plug 'neoclide/coc.nvim', {'branch': 'release'} \" Initialize plugin system call plug#end() Save this in your ~/.vimrc or init.vim file. In a new shell run the command vim -c 'PlugInstall | qall . This will install our plugins and quit. Now we can open a new vim instance and have CoC enabled. I would suggest using the example config to get started and customize as you need.","title":"CoC"},{"location":"setup/vim/#coc-extensions","text":"Extensions overview Extensions add functionality to CoC such as interacting with Language servers over LSP. I suggest adding any extensions you want to use to g:coc_global_extensions in your .vimrc or init.vim file. let g:coc_global_extensions = ['coc-actions', 'coc-rust-analyzer', 'coc-json', 'coc-yank']","title":"CoC Extensions"},{"location":"setup/vim/#spacevim","text":"SpaceVim is a complete Vim configuration. Read through the documentation provided by spacevim for full overview of how to best use it. GitHub Page Setup as Rust IDE","title":"SpaceVim"},{"location":"setup/vim/#other-vim-plugin-suggestions","text":"Name Description Recover.vim Show a diff of the swap file before loading ctrlp.vim Fuzzy finding of files, buffers and more editorconfig-vim Use of .editorconfig files to set indentation etc vim-easy-align Handle aligning text vim-sayonara Deletes the buffer and handles windows more intelligently vim-fugitive Extensive Git integration added to Vim vim-repeat Beef up the default . repeater vim-rhubarb Add fancy extras for GitHub to the vim-fugitive plugin vim-which-key Keybinding manager nerdtree-git-plugin Add git information to NerdTree vim-gitgutter Show git changes in margin of file buffer vim-matchup Highlight, navigate and operate on sets of matching text vim-rainbow Colorize tabs, parens to make them easier to see lightline.vim Adds a powerline like status bar at the bottom vim-highlightedyank Highlights line after y is pressed tabman.vim Simple management of tabs in Vim nerdtree File Explorer tab vim-session Extended session management for Vim papercolor-theme Light theme gruvbox Configurable dark mode theme dracula Configurable dark mode theme fzf Fuzzy finding inside Vim/NVim fzf.vim Additional Vim setup for FZF vim-markdown-toc Manage ToC sections for Markdown files vim-toml Add support for TOML files","title":"Other Vim plugin suggestions"},{"location":"setup/vscode/","text":"Visual Studio Code \u00b6 Rust specific extensions Other VS Code Extensions Rust specific extensions \u00b6 Install the following extensions using CMD+P then type ext install ... to install Name Description rust-lang.rust Main Rust component, can use Rust Analyzer or RLS serayuzgur.crates Adds version and crate validation when viewing Cargo.toml bungcip.better-toml Provides better syntax highlighting for TOML files Optionally update the rust-client.engine to rust-analyzer . Rust Analyzer is a future replacement for RLS and provides better autocomplete. Other VS Code Extensions \u00b6 Name Description editorconfig.editorconfig Formats documents based on .editorconfig files yzhang.markdown-all-in-one Helpers for editing .md files including table formatting and automatic ToC adamhartford.vscode-base64 Encode/Decode base64 strings directly in VSCode redhat.vscode-yaml Support for YAML files including schema validation shan.code-settings-sync Sync settings to a GitHub Gist, good for backup or syncing to another computer ms-vscode-remote.vscode-remote-extensionpack Remote dev in a container, remote SSH host and others ms-vscode.go For writing Go code as well ms-python.python For writing Python code as well robbowen.synthwave-vscode Retro style theme","title":"VS Code"},{"location":"setup/vscode/#visual-studio-code","text":"Rust specific extensions Other VS Code Extensions","title":"Visual Studio Code "},{"location":"setup/vscode/#rust-specific-extensions","text":"Install the following extensions using CMD+P then type ext install ... to install Name Description rust-lang.rust Main Rust component, can use Rust Analyzer or RLS serayuzgur.crates Adds version and crate validation when viewing Cargo.toml bungcip.better-toml Provides better syntax highlighting for TOML files Optionally update the rust-client.engine to rust-analyzer . Rust Analyzer is a future replacement for RLS and provides better autocomplete.","title":"Rust specific extensions"},{"location":"setup/vscode/#other-vs-code-extensions","text":"Name Description editorconfig.editorconfig Formats documents based on .editorconfig files yzhang.markdown-all-in-one Helpers for editing .md files including table formatting and automatic ToC adamhartford.vscode-base64 Encode/Decode base64 strings directly in VSCode redhat.vscode-yaml Support for YAML files including schema validation shan.code-settings-sync Sync settings to a GitHub Gist, good for backup or syncing to another computer ms-vscode-remote.vscode-remote-extensionpack Remote dev in a container, remote SSH host and others ms-vscode.go For writing Go code as well ms-python.python For writing Python code as well robbowen.synthwave-vscode Retro style theme","title":"Other VS Code Extensions"}]}